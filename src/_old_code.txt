%% Unused code

%%%% Original primal update
%     % Update the primal variable
%      temp(ind_primal) = factor2*(w(ind_primal) + theta*(w(ind_primal)-wminus(ind_primal)));
%      u = u + A(:,ind_primal)*temp(ind_primal);

%%%% Original dual update
%   tmp2 = (pplus'*A)';
%   tmp2 = tmp2 - Ed;

%%%% Obsolete stuff
    % Update the dual variable I -- Loop + allocation
%     if(mod(k,10) == 0) % Every 10 iterations, perform a full update
%         p0 = pplus;
%         tmp2 = ((p0'*A)')/norm_sum - Ed;
%         test_fac = tmp2;
%     else % Determine nonzero entries 
%         idx_dual = all_ind((sigma*lambda - sigma*sum(abs(pplus/norm_sum-p0)) - abs(w - sigma*test_fac) < 0));
%         tmp2 = zeros(length(w),1);
%         tmp2(idx_dual) = -Ed(idx_dual);
%         for i=idx_dual
%             tmp2(i) = tmp2(i) + pplus'*A(:,i);
%         end
%     end


    %temp0 = Ed - (p0'*A)';
%     uplus = u;
%     idx_primal = ind_primal.*(1:m); idx_primal(idx_primal == 0) = [];
%     for l=idx_primal
%         temp = factor2*(w(l) + theta*(w(l)-wminus(l)));
%         uplus = uplus +  (A(:,l).'*temp)';
%     end

    
    % NOTE: Potential gain in speed if we determine in advance which
    % features we need to compute.
    % The factor (pplus'*A(:,ind_dual))'; is ineffective...
    
%     ind_dual = (sigma*lambda - abs(w + sigma*temp0) - sigma*sum(abs(pplus-p0)) < 0)';
%     ind_dual = ind_dual.*(1:m); ind_dual(ind_dual == 0) = [];
%     
%     % Update the dual variable
%     wplus = zeros(length(w),1);
%     
%     for j=ind_dual
%         wplus(l) = w(l) - sigma*(pplus'*A(:,l) - Ed(l));
%     end
% 
% p0 = exp(u-max(u));
% p0 = p0/sum(p0);
% m = length(w);